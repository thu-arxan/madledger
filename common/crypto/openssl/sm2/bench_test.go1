package sm2

import (
	"madledger/common/crypto/openssl/sm3"
	"sync"
	"testing"
	"time"
)

func BenchmarkGenKey(b *testing.B) {
	for i := 0; i < b.N; i++ {
		priv, err := GenerateKey()
		if err != nil || priv == nil || priv.PublicKey.Key == nil {
			b.Error(err)
		}
	}
}

func BenchmarkMarshalPriv(b *testing.B) {
	priv, err := GenerateKey()
	if err != nil || priv == nil {
		b.Error(err)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := MarshalSm2UnecryptedPrivateKey(priv)
		if err != nil {
			b.Error(err)
		}
	}
}

func BenchmarkMarshalPub(b *testing.B) {
	priv, err := GenerateKey()
	if err != nil || priv == nil {
		b.Error(err)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := MarshalSm2PublicKey(priv.PublicKey)
		if err != nil {
			b.Error(err)
		}
	}
}

func BenchmarkParsePriv(b *testing.B) {
	priv, err := GenerateKey()
	if err != nil || priv == nil {
		b.Error(err)
	}
	privByte, err := MarshalSm2UnecryptedPrivateKey(priv)
	if err != nil {
		b.Error(err)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := ParseSm2PrivateKey(privByte)
		if err != nil {
			b.Error(err)
		}
	}
}

func BenchmarkParsePub(b *testing.B) {
	priv, err := GenerateKey()
	if err != nil || priv == nil {
		b.Error(err)
	}
	pubByte, err := MarshalSm2PublicKey(priv.PublicKey)
	if err != nil {
		b.Error(err)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := ParseSm2PublicKey(pubByte)
		if err != nil {
			b.Error(err)
		}
	}
}

func BenchmarkVerifyParallel(b *testing.B) {
	priv, err := GenerateKey()
	if err != nil {
		b.Error(err)
	}
	pub := priv.PublicKey

	hash := sm3.Sm3Sum([]byte("hello"))

	r, s, err := Sign(priv, hash)
	if err != nil || r == nil || s == nil {
		b.Error(err)
	}
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			if !Verify(pub, hash, r, s) {
				b.Error(GetErrors())
			}
		}
	})
}

func BenchmarkVerifyUidParallel(b *testing.B) {
	priv, err := GenerateKey()
	if err != nil {
		b.Error(err)
	}
	pub := priv.PublicKey

	msg := []byte("hello")
	uid := []byte(DefaultUID)

	r, s, err := Sm2Sign(priv, msg, uid)
	if err != nil || r == nil || s == nil {
		b.Error(err)
	}
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			if !Sm2Verify(pub, msg, uid, r, s) {
				b.Error(GetErrors())
			}
		}
	})
}

func BenchmarkVerify(b *testing.B) {
	priv, err := GenerateKey()
	if err != nil {
		b.Error(err)
	}
	pub := priv.PublicKey

	hash := sm3.Sm3Sum([]byte("hello"))

	r, s, err := Sign(priv, hash)
	if err != nil || r == nil || s == nil {
		b.Error(err)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if !Verify(pub, hash, r, s) {
			b.Error(GetErrors())
		}
	}
}

func BenchmarkVerifyUid(b *testing.B) {
	priv, err := GenerateKey()
	if err != nil {
		b.Error(err)
	}
	pub := priv.PublicKey

	msg := []byte("hello")
	uid := []byte(DefaultUID)
	r, s, err := Sm2Sign(priv, msg, uid)
	if err != nil || r == nil || s == nil {
		b.Error(err)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if !Sm2Verify(pub, msg, uid, r, s) {
			b.Error(GetErrors())
		}
	}
}

func BenchmarkVerifyStandardParallel(b *testing.B) {
	priv, err := GenerateKey()
	if err != nil {
		b.Error(err)
	}
	pub := priv.PublicKey

	hash := sm3.Sm3Sum([]byte("hello"))

	sig, err := SignData(priv, hash)
	if err != nil || sig == nil {
		b.Error(err)
	}
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			if p, err := StandardVerify(pub, hash, sig); err != nil || p != true {
				b.Error(GetErrors())
			}
		}
	})

}
func BenchmarkVerifyStandardUidParallel(b *testing.B) {
	priv, err := GenerateKey()
	if err != nil {
		b.Error(err)
	}
	pub := priv.PublicKey

	msg := []byte("hello")
	uid := []byte(DefaultUID)

	sig, err := Sm2SignData(priv, msg, uid)
	if err != nil || sig == nil {
		b.Error(err)
	}
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			if !Sm2VerifyData(pub, msg, uid, sig) {
				b.Error(GetErrors())
			}
		}
	})

}
func TestTPSVerify(t *testing.T) {
	priv, err := GenerateKey()
	if err != nil {
		t.Error(err)
	}
	pub := priv.PublicKey

	hash := sm3.Sm3Sum([]byte("hello"))

	sig, err := SignData(priv, hash)
	if err != nil || sig == nil {
		t.Error(err)
	}
	ti := time.Now()
	var wg sync.WaitGroup
	ch := make(chan int, 1000)

	for i := 0; i < 100000; i++ {
		ch <- 1
		wg.Add(1)
		go func() {
			defer wg.Done()
			defer func() {
				<-ch
			}()
			if !VerifyData(pub, hash, sig) {
				t.Error(GetErrors())
			}
		}()

	}

	wg.Wait()
	t.Log("OpenSSL sm2 verify:", 100000.0/time.Since(ti).Seconds())
}
